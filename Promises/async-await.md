# `async` / `await`

The `async` / `await` syntax allows to work with promises in a more comfortable fashion.

## Async functions

The `async` keyword can be placed before a function:

```js
async function foo() {
    return 1;
}
```

It makes the function **always return a promise**. Non-promise values are automatically wrapped in a resolved promise.

## `await`

The `await` keyword only works inside async functions. It makes the JS engine wait until the promise is settled, and its result is returned.

```js
async function foo() {
    let promise = new Promise((resolve, reject) => {
        setTimeout(() => resolve('Done!'), 1000)
    });

    let result = await promise;

    console.log(result);
}
```

The function execution is **suspended** at the line that contains the `await` keyword, and **resumed** when the promise settles.

The wait doesn't take any resources, because the JS engine can do other jobs in the meantime (execute other scripts, handle events etc.). Overall, it's a more elegant and legible way of obtaining promise results than `promise.then()`.

Using `await` in regular functions leads to a syntax error.

Let's rewrite the `showAvatar` example from the [promise chaining chapter](./promise-chaining.md) using `async`/`await`:

```js
async function showAvatar() {
    let response = await fetch('/resource/user.json');
    let user = await response.json();

    let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);
    let githubUser = await githubResponse.json();

    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = 'promise-avatar-example';
    document.body.append(img);

    await new Promise((resolve, reject) => setTimeout(resolve, 3000));

    img.remove();

    return githubUser;
}
```

Top level `await` is supported in all modern browsers.

### `await` and thenables

Just like `promise.then()`, `await` accepts all thenable objects (ones with a callable `then()` method).

```js
class Thenable {
    constructor(num) {
        this.num = num;
    }

    then(resolve, reject) {
        console.log(resolve);
        setTimeout(() => resolve(this.num * 2), 1000);
    }
}

async function foo() {
    let result = await new Thenable(1);
    console.log(result);
}
```

If `await` gets a non-promise thenable object, it calls the object's `then()` method providing built-in functions `resolve` and `reject` as arguments, just like a regular promise executor. Next, `await` waits until one of them is called, and proceeds with the result.

## Error handling

If a promise resolves, `await promise` returns the result. In case of rejection, it throws the error. This code:

```js
async function foo() {
    await Promise.reject(new Error('An error occurred.'));
}
```

...is the same as:

```js
async function foo() {
    throw new Error('An error occurred.');
}
```

Errors can be handled using `try... catch`, same as with the regular `throw`:

```js
async function foo() {
    try {
        let response = await fetch('/no-user-here');
        let user = await response.json();
    } catch(err) {
        console.log(err);
    }
}
```

If there is no `try... catch`, and the promise generated by the call to the async function is rejected, we can still append `.catch` to handle it:

```js
async function f() {
    let response = await fetch('http://no-such-url');
}

f().catch(console.log);
```

In fact, at the top level of the code, when we're outside of any async function, it's a standard practice to add `.catch` or `.then` to handle the final result in case of any fall-through errors.

If we don't add `.catch`, we'll get an unhandled promise error, which we can catch using the global `unhandledrejection` event.

Also, `async`/`await` works with `Promise.all`:

```js
let results = await Promise.all([
    fetch(url1),
    fetch(url2),
]);
```
